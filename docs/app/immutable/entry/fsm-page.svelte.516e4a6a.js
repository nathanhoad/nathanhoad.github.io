import{S as it,i as ot,s as rt,z as ht,A as lt,B as pt,g as ft,d as mt,C as ut,k as n,r,a as f,l as s,m as i,u as h,h as t,c as m,J as dt,p as R,b as l,H as a,n as ct}from"../chunks/index.1a1b1f9a.js";import{A as vt}from"../chunks/article-page.e7786417.js";const yt=""+new URL("../assets/sharing-states.5f1e08f4.mp4",import.meta.url).href;function _t(oe){let p,y,u,_,b,re,Z,I,he,Q,x,le,V,A,pe,z,g,d,Re,fe,U,me,J,$,ue,X,C,de,K,N,ce,Y,S,ve,ee,T,ye,te,w,P,W,B,_e,be,L,ge,we,v,j,H,Ee,ke,M,Pe,Ie,q,xe,Ae,O,$e,ae,c,Ce,D,Ne,Se,F,Te,De,G,Fe,Ge;return{c(){p=n("header"),y=n("h1"),u=r("Using finite state machines for behaviour"),_=f(),b=n("aside"),re=r("May 2021"),Z=f(),I=n("p"),he=r("I use finite state machines for the behaviour of townsfolk and enemies in my game."),Q=f(),x=n("p"),le=r("What does that mean?"),V=f(),A=n("p"),pe=r("At any given time an NPC can be in one of many “behaviour states” depending on what's happening to them."),z=f(),g=n("figure"),d=n("video"),fe=f(),U=n("figcaption"),me=r("Designing states with dependency injection means they can be shared amongst different kinds of NPCs."),J=f(),$=n("p"),ue=r("For example, an enemy might contain states for “patrolling” and “chasing”."),X=f(),C=n("p"),de=r(`Breaking up behaviour makes it simpler to think about. When “patrolling”, the enemy just follows a path back and forward until they see\r
    the player. Then they change state to “chasing” where they move towards the player. If they lose sight of the player they go back to\r
    “patrolling” and return to their path.`),K=f(),N=n("p"),ce=r("Breaking up behaviour has another benefit - you can share them with other types of NPC."),Y=f(),S=n("p"),ve=r("A friendly person in a town might also make use of the patrolling state."),ee=f(),T=n("p"),ye=r(`There's no real limit to how many states you can have or how much you share them but there are two rules that I've found have helped\r
    keep things manageable:`),te=f(),w=n("ol"),P=n("li"),W=n("p"),B=n("em"),_e=r("States define their dependencies"),be=f(),L=n("p"),ge=r(`Anything external information that the state needs should be explicitly defined. In the case of Godot this means declaring export\r
        variables that can be populated by the owner node.`),we=f(),v=n("li"),j=n("p"),H=n("em"),Ee=r("States don't transition to other states themselves"),ke=f(),M=n("p"),Pe=r("Each state should have no idea that other states exist. That's the best way to keep them simple and shareable."),Ie=f(),q=n("p"),xe=r("Instead of transitioning itself, a state should simply provide a list of events that can happen while in that state."),Ae=f(),O=n("p"),$e=r(`In the example from earlier, the patrolling state might signal that it has seen the player. From there the NPC that owns the state\r
        machine can decide whether it needs to transition or not.`),ae=f(),c=n("p"),Ce=r("If you're interested in using a finite state machine for your game then have a look at my videos on "),D=n("a"),Ne=r("enemy behaviour"),Se=r(`\r
    and\r
    `),F=n("a"),Te=r("smarter NPCs"),De=r(`\r
    and have a look at\r
    `),G=n("a"),Fe=r("GDQuest's guide to finite state machines"),Ge=r("."),this.h()},l(e){p=s(e,"HEADER",{});var o=i(p);y=s(o,"H1",{});var Ue=i(y);u=h(Ue,"Using finite state machines for behaviour"),Ue.forEach(t),_=m(o),b=s(o,"ASIDE",{});var We=i(b);re=h(We,"May 2021"),We.forEach(t),o.forEach(t),Z=m(e),I=s(e,"P",{});var Be=i(I);he=h(Be,"I use finite state machines for the behaviour of townsfolk and enemies in my game."),Be.forEach(t),Q=m(e),x=s(e,"P",{});var Le=i(x);le=h(Le,"What does that mean?"),Le.forEach(t),V=m(e),A=s(e,"P",{});var je=i(A);pe=h(je,"At any given time an NPC can be in one of many “behaviour states” depending on what's happening to them."),je.forEach(t),z=m(e),g=s(e,"FIGURE",{});var ne=i(g);d=s(ne,"VIDEO",{src:!0,width:!0,height:!0}),i(d).forEach(t),fe=m(ne),U=s(ne,"FIGCAPTION",{});var He=i(U);me=h(He,"Designing states with dependency injection means they can be shared amongst different kinds of NPCs."),He.forEach(t),ne.forEach(t),J=m(e),$=s(e,"P",{});var Me=i($);ue=h(Me,"For example, an enemy might contain states for “patrolling” and “chasing”."),Me.forEach(t),X=m(e),C=s(e,"P",{});var qe=i(C);de=h(qe,`Breaking up behaviour makes it simpler to think about. When “patrolling”, the enemy just follows a path back and forward until they see\r
    the player. Then they change state to “chasing” where they move towards the player. If they lose sight of the player they go back to\r
    “patrolling” and return to their path.`),qe.forEach(t),K=m(e),N=s(e,"P",{});var Oe=i(N);ce=h(Oe,"Breaking up behaviour has another benefit - you can share them with other types of NPC."),Oe.forEach(t),Y=m(e),S=s(e,"P",{});var Ze=i(S);ve=h(Ze,"A friendly person in a town might also make use of the patrolling state."),Ze.forEach(t),ee=m(e),T=s(e,"P",{});var Qe=i(T);ye=h(Qe,`There's no real limit to how many states you can have or how much you share them but there are two rules that I've found have helped\r
    keep things manageable:`),Qe.forEach(t),te=m(e),w=s(e,"OL",{});var se=i(w);P=s(se,"LI",{});var ie=i(P);W=s(ie,"P",{});var Ve=i(W);B=s(Ve,"EM",{});var ze=i(B);_e=h(ze,"States define their dependencies"),ze.forEach(t),Ve.forEach(t),be=m(ie),L=s(ie,"P",{});var Je=i(L);ge=h(Je,`Anything external information that the state needs should be explicitly defined. In the case of Godot this means declaring export\r
        variables that can be populated by the owner node.`),Je.forEach(t),ie.forEach(t),we=m(se),v=s(se,"LI",{});var E=i(v);j=s(E,"P",{});var Xe=i(j);H=s(Xe,"EM",{});var Ke=i(H);Ee=h(Ke,"States don't transition to other states themselves"),Ke.forEach(t),Xe.forEach(t),ke=m(E),M=s(E,"P",{});var Ye=i(M);Pe=h(Ye,"Each state should have no idea that other states exist. That's the best way to keep them simple and shareable."),Ye.forEach(t),Ie=m(E),q=s(E,"P",{});var et=i(q);xe=h(et,"Instead of transitioning itself, a state should simply provide a list of events that can happen while in that state."),et.forEach(t),Ae=m(E),O=s(E,"P",{});var tt=i(O);$e=h(tt,`In the example from earlier, the patrolling state might signal that it has seen the player. From there the NPC that owns the state\r
        machine can decide whether it needs to transition or not.`),tt.forEach(t),E.forEach(t),se.forEach(t),ae=m(e),c=s(e,"P",{});var k=i(c);Ce=h(k,"If you're interested in using a finite state machine for your game then have a look at my videos on "),D=s(k,"A",{href:!0});var at=i(D);Ne=h(at,"enemy behaviour"),at.forEach(t),Se=h(k,`\r
    and\r
    `),F=s(k,"A",{href:!0});var nt=i(F);Te=h(nt,"smarter NPCs"),nt.forEach(t),De=h(k,`\r
    and have a look at\r
    `),G=s(k,"A",{href:!0});var st=i(G);Fe=h(st,"GDQuest's guide to finite state machines"),st.forEach(t),Ge=h(k,"."),k.forEach(t),this.h()},h(){dt(d.src,Re=yt)||R(d,"src",Re),d.autoplay=!0,d.playsInline=!0,d.muted=!0,d.loop=!0,R(d,"width","1920"),R(d,"height","1080"),R(D,"href","https://youtu.be/tZgEXWleWxg"),R(F,"href","https://youtu.be/CZV9aNiZdRs"),R(G,"href","https://www.gdquest.com/tutorial/godot/design-patterns/finite-state-machine/")},m(e,o){l(e,p,o),a(p,y),a(y,u),a(p,_),a(p,b),a(b,re),l(e,Z,o),l(e,I,o),a(I,he),l(e,Q,o),l(e,x,o),a(x,le),l(e,V,o),l(e,A,o),a(A,pe),l(e,z,o),l(e,g,o),a(g,d),a(g,fe),a(g,U),a(U,me),l(e,J,o),l(e,$,o),a($,ue),l(e,X,o),l(e,C,o),a(C,de),l(e,K,o),l(e,N,o),a(N,ce),l(e,Y,o),l(e,S,o),a(S,ve),l(e,ee,o),l(e,T,o),a(T,ye),l(e,te,o),l(e,w,o),a(w,P),a(P,W),a(W,B),a(B,_e),a(P,be),a(P,L),a(L,ge),a(w,we),a(w,v),a(v,j),a(j,H),a(H,Ee),a(v,ke),a(v,M),a(M,Pe),a(v,Ie),a(v,q),a(q,xe),a(v,Ae),a(v,O),a(O,$e),l(e,ae,o),l(e,c,o),a(c,Ce),a(c,D),a(D,Ne),a(c,Se),a(c,F),a(F,Te),a(c,De),a(c,G),a(G,Fe),a(c,Ge)},p:ct,d(e){e&&t(p),e&&t(Z),e&&t(I),e&&t(Q),e&&t(x),e&&t(V),e&&t(A),e&&t(z),e&&t(g),e&&t(J),e&&t($),e&&t(X),e&&t(C),e&&t(K),e&&t(N),e&&t(Y),e&&t(S),e&&t(ee),e&&t(T),e&&t(te),e&&t(w),e&&t(ae),e&&t(c)}}}function bt(oe){let p,y;return p=new vt({props:{path:"/fsm",title:"Using finite state machines for behaviour",description:"Finite state machines help break apart the code that powers character behaviour and make it easier to understand and reuse.",$$slots:{default:[_t]},$$scope:{ctx:oe}}}),{c(){ht(p.$$.fragment)},l(u){lt(p.$$.fragment,u)},m(u,_){pt(p,u,_),y=!0},p(u,[_]){const b={};_&1&&(b.$$scope={dirty:_,ctx:u}),p.$set(b)},i(u){y||(ft(p.$$.fragment,u),y=!0)},o(u){mt(p.$$.fragment,u),y=!1},d(u){ut(p,u)}}}class Et extends it{constructor(p){super(),ot(this,p,null,bt,rt,{})}}export{Et as default};
